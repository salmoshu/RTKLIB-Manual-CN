# 附录B: 常见问题

## B.1 RTKLIB观测数据中的时间

```c
/* pntpos (pntpos.c) */
sol->time=obs[0].time;
...
/* satellite positions, velocities and clocks */
satposs(sol->time,obs,n,nav,opt_.sateph,rs,dts,var,svh);
```

**问题：**

源码中将 obs[0].time 作为星历选择时间传递给 satposs 函数，这样对于每一颗观测卫星，都要使用第一颗观测卫星的数据接收时间作为选择星历的时间标准。是否应该每颗卫星都使用自己的观测时间？或者应该使用每颗卫星自己的信号发射时间？还是说这点差别对选择合适的星历其实没有关系？

**解答：**

在 RTKLIB 的单点定位中，使用 obs[0].time 作为所有卫星的星历选择时间是合理的，主要原因如下：

- **时间差异微小**：接收时间差异（几十毫秒）相对于星历时间分辨率（2 小时）可以忽略，对星历选择和位置计算影响甚微。
- **简化实现**：统一时间参考减少了代码的复杂性，适合单点定位的低精度需求。

另外，RTKLIB 在取每一个历元的数据时，会对时间进行了判断，每个历元内观测量的时间相较于整秒间隔小于DTTOL（0.025s）。。

## B.2 raim_fde 对卫星数目的要求

```c
/* pntpos (pntpos.c)*/
/* RAIM FDE */
if (!stat&&n>=6&&opt->posopt[4]) {
    stat=raim_fde(obs,n,rs,dts,var,svh,nav,&opt_,ssat,sol,azel_,vsat,resp,msg);
}
```

**问题：**

这里规定能够执行 raim_fde 函数的前提是数目大于等于 6，感觉不是只要大于等于 5 就可以了吗？

**解答：**

RTKLIB 中的 raim 采用的是伪距残差检测法，伪距残差检测法要求至少有 6 颗可见卫星。

具体而言，必须要有2个冗余方程，所以卫星数需要大于等于6。如果只有5颗卫星，raim_fde 算法会排除一颗卫星进行位置计算，就只剩下4颗星。4个方程解4个未知数，是没有残差的，因为此时解算得到的是一个闭式解，残差为0。

## B.3 `satexclude()` 的作用机制

**问题：**

对于步骤3中检测，先验证状态排除标志，后验证导航系统，这样就可能出现排除标志符合要求而所属系统不符合要求的状况，而步骤3中做法会将上述状况设为 included。又或者，在步骤3中检测之后仍验证了 `svh>0`，那如果出现 `svh` 不合乎要求而排除标志符合要求的状况，步骤3中做法却会将上述状况设为 included。

**解答：**

设置定位排除的卫星时候，有两种模式，一种是强制剔除某颗卫星，另一种是强制加上某颗卫星。

对于后者，此时需要在卫星ID前加上“+”，表示即使卫星状态不佳，该卫星也会被包括在定位中。该功能主要是为了分析问题卫星所在定位过程中所产生的影响。

## B.4 无电离层组合

**问题：**

无电离层组合的误差方差为什么要乘以 3.0^2？

**解答：**

在 GNSS（如 GPS）中，无电离层线性组合（IFLC）通过线性组合 L1（$f_1 = 1575.42 \, \text{MHz}$）和 L2（$f_2 = 1227.60 \, \text{MHz}$）频率的观测值（如伪距或载波相位）来消除电离层延迟一阶项[4]。电离层延迟与频率平方成反比，因此组合公式为：

$$P_{IF} = \frac{f_1^2}{f_1^2 - f_2^2} P_1 - \frac{f_2^2}{f_1^2 - f_2^2} P_2$$

其中，系数 $k_1 = \frac{f_1^2}{f_1^2 - f_2^2}$，$k_2 = \frac{f_2^2}{f_1^2 - f_2^2}$。计算频率比：

$$\left( \frac{f_1}{f_2} \right)^2 = \left( \frac{1575.42}{1227.60} \right)^2 \approx 1.647$$

代入：

$$k_1 = \frac{1.647}{1.647 - 1} \approx \frac{1.647}{0.647} \approx 2.546$$

$$k_2 = \frac{1}{1.647 - 1} \approx \frac{1}{0.647} \approx 1.546$$

组合后，噪声方差通过误差传播计算，放大因子为：

$$\sqrt{k_1^2 + k_2^2} = \sqrt{2.546^2 + 1.546^2} \approx \sqrt{8.872} \approx 2.978$$

为简化计算，实际应用中近似为 3.0，方差放大 $ 3.0^2 = 9.0 $，故使用 varr *= SQR(3.0)。

**综上所述：**

GNSS 无电离层组合（IFLC）使用 GPS L1 和 L2 频率（1575.42 MHz 和 1227.60 MHz）的平方比，得到组合系数 2.546 和 1.546。噪声方差放大因子为 $\sqrt{2.546^2 + 1.546^2} \approx 2.978 \approx 3.0$。为简化计算，实际使用 varr *= SQR(3.0)，表示方差放大 9 倍。

## B.5 差分数据中 GLO 卫星无法投入计算

**问题：**

<img style="width: 100%; margin: 0 auto; display: block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250711-135845.jpg"/>
<p style="text-align: center; font-family: 'Microsoft YaHei', SimSun, Arial, sans-serif; font-size: 14px;">图B.5-1 GLO 卫星无法投入计算的现象</p>

**Debug：**

```c
/* save_msm_obs (rtcm3.c): save obs data in MSM message */
1. freq 为 0，导致 L 数据为0
2. freq=fcn<-7?0.0:code2freq(sys,code[k],fcn);      
   fcn 标识为 -8，导致 freq 为 0
3. rtcm->nav.geph[prn-1].sat 为 0，导致 fcn 无法被正常赋值
	if ...
	else if (rtcm->nav.geph[prn-1].sat==sat) {
	     fcn=rtcm->nav.geph[prn-1].frq;
	}
4. GLO 卫星会根据观测数据中的 PRN 号到星历数据中找到对应的频段号才能计算出最终的载波相位值。
```

**解决：**

```c
/* 实时程序 */
// 在 decoderaw 中解析 rtcm3 的部分，将 rover 的 nav 结构体拷贝给 base 的 nav 结构体
if(index==0) {
   memcpy(&svr->rtcm[1].nav, nav, sizeof(nav_t));
}

/* 后处理程序 */
如果是后处理的话，RTCM 1020 报文需要单独合入 RINEX 中。
```

**总结：**

除了星历中包含 GLONASS FCN的信息，RTCM MSM5 和 MSM7 也包含该内容。不过通常差分数据的格式是 MSM4。

由资料[18]可知，RTKLIB 还无法从任何 MSM 消息中提取频率信息，并且如果没有 GLONASS 星历表消息，则无法为任何 MSM 消息（1-7）包含 GLONASS 相位观测值。不过 demo5 代码中添加了一项功能，解决了 MSM5 和 MSM7 消息的这个问题，但其他消息仍然无法在 RINEX 文件中生成相位观测值。

## B.6 雅可比矩阵、几何矩阵和设计矩阵

**问题：**

雅可比矩阵、几何矩阵和设计矩阵是一回事吗？

**解答：**

**是的**。在 GNSS 定位中，**雅可比矩阵 = 几何矩阵 = 设计矩阵**，都是指将非线性观测方程线性化后，状态量（如接收机位置、钟差）对观测值（如伪距）的偏导数构成的矩阵，记作 H 或 G

| 名称        | 语境/侧重点         | 说明                                        |
| --------- | -------------- | ----------------------------------------- |
| **雅可比矩阵** | 数学/优化          | 强调它是非线性函数的一阶偏导矩阵，用于线性化观测模型。               |
| **几何矩阵**  | GNSS 导航/几何因子分析 | 强调它包含了**卫星与接收机之间的几何关系**（如方向余弦），直接影响 GDOP。 |
| **设计矩阵**  | 最小二乘/参数估计      | 强调它是**观测方程对未知参数的线性系数矩阵**，用于构建法方程。         |

笔者将尽量使用雅可比矩阵的描述，因为它使用更为广泛。
